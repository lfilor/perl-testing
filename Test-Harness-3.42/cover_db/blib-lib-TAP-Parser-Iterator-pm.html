<!DOCTYPE html
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<!--
This file was generated by Devel::Cover Version 1.36
Devel::Cover is copyright 2001-2019, Paul Johnson (paul@pjcj.net)
Devel::Cover is free. It is licensed under the same terms as Perl itself.
The latest version of Devel::Cover should be available from my homepage:
http://www.pjcj.net
-->
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
    <meta http-equiv="Content-Language" content="en-us"></meta>
    <link rel="stylesheet" type="text/css" href="cover.css"></link>
    <link rel="stylesheet" type="text/css" href="cover.css"></link>
    <title>File Coverage: blib/lib/TAP/Parser/Iterator.pm</title>
</head>
<body>
<h1>File Coverage</h1>
<table>
<tr><td class="h" align="right">File:</td><td align="left">blib/lib/TAP/Parser/Iterator.pm</td></tr>
<tr><td class="h" align="right">Coverage:</td><td align="left" class="c0">73.9%</td></tr>
</table>
<div><br/></div>
<table>
<tr><th>line</th><th>stmt</th><th>bran</th><th>cond</th><th>sub</th><th>pod</th><th>time</th><th>code</th></tr>
<tr><td class="h">1</td><td></td><td></td><td></td><td></td><td></td><td></td><td class="s">package TAP::Parser::Iterator;</td></tr>
<tr><td class="h">2</td><td colspan="7"></td></tr><tr><td class="h">3</td><td><div class="c3">39</div><div class="c3">39</div><div class="c3">39</div></td><td></td><td></td><td><div class="c3"><a href="blib-lib-TAP-Parser-Iterator-pm--subroutine.html#L3">39</a></div></td><td></td><td><div>89030</div><div>36</div><div>511</div></td><td class="s">use strict;</td></tr>
<tr><td class="h">4</td><td><div class="c3">39</div><div class="c3">39</div><div class="c3">39</div></td><td></td><td></td><td><div class="c3"><a href="blib-lib-TAP-Parser-Iterator-pm--subroutine.html#L4">39</a></div></td><td></td><td><div>77</div><div>25</div><div>669</div></td><td class="s">use warnings;</td></tr>
<tr><td class="h">5</td><td colspan="7"></td></tr><tr><td class="h">6</td><td><div class="c3">39</div><div class="c3">39</div><div class="c3">39</div></td><td></td><td></td><td><div class="c3"><a href="blib-lib-TAP-Parser-Iterator-pm--subroutine.html#L6">39</a></div></td><td></td><td><div>87</div><div>33</div><div>6327</div></td><td class="s">use base &#39;TAP::Object&#39;;</td></tr>
<tr><td class="h">7</td><td colspan="7"></td></tr><tr><td class="h">8 - 16</td><td colspan="6"></td><td class="s"><pre>=head1 NAME

TAP::Parser::Iterator - Base class for TAP source iterators

=head1 VERSION

Version 3.42

=cut</pre></td></tr>
<tr><td class="h">17</td><td colspan="7"></td></tr><tr><td class="h">18</td><td></td><td></td><td></td><td></td><td></td><td></td><td class="s">our $VERSION = &#39;3.42&#39;;</td></tr>
<tr><td class="h">19</td><td colspan="7"></td></tr><tr><td class="h">20 - 62</td><td colspan="6"></td><td class="s"><pre>=head1 SYNOPSIS

&nbsp;&nbsp;# to subclass:
&nbsp;&nbsp;use TAP::Parser::Iterator ();
&nbsp;&nbsp;use base &#39;TAP::Parser::Iterator&#39;;
&nbsp;&nbsp;sub _initialize {
&nbsp;&nbsp;&nbsp;&nbsp;# see TAP::Object...
&nbsp;&nbsp;}

&nbsp;&nbsp;sub next_raw { ... }
&nbsp;&nbsp;sub wait&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ ... }
&nbsp;&nbsp;sub exit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ ... }

=head1 DESCRIPTION

This is a simple iterator base class that defines L&lt;TAP::Parser&gt;&#39;s iterator
API.&nbsp;&nbsp;Iterators are typically created from L&lt;TAP::Parser::SourceHandler&gt;s.

=head1 METHODS

=head2 Class Methods

=head3 C&lt;new&gt;

Create an iterator.&nbsp;&nbsp;Provided by L&lt;TAP::Object&gt;.

=head2 Instance Methods

=head3 C&lt;next&gt;

 while ( my $item = $iter-&gt;next ) { ... }

Iterate through it, of course.

=head3 C&lt;next_raw&gt;

B&lt;Note:&gt; this method is abstract and should be overridden.

 while ( my $item = $iter-&gt;next_raw ) { ... }

Iterate raw input without applying any fixes for quirky input syntax.

=cut</pre></td></tr>
<tr><td class="h">63</td><td colspan="7"></td></tr><tr><td class="h">64</td><td></td><td></td><td></td><td></td><td></td><td></td><td class="s">sub next {</td></tr>
<tr><td class="h">65</td><td><div class="c3">1691</div></td><td></td><td></td><td><div class="c3"><a href="blib-lib-TAP-Parser-Iterator-pm--subroutine.html#L65">1691</a></div></td><td><div class="c3">1</div></td><td><div>4651</div></td><td class="s">&nbsp;&nbsp;&nbsp;&nbsp;my $self = shift;</td></tr>
<tr><td class="h">66</td><td><div class="c3">1691</div></td><td></td><td></td><td></td><td></td><td><div>2213</div></td><td class="s">&nbsp;&nbsp;&nbsp;&nbsp;my $line = $self-&gt;next_raw;</td></tr>
<tr><td class="h">67</td><td colspan="7"></td></tr><tr><td class="h">68</td><td></td><td></td><td></td><td></td><td></td><td></td><td class="s">&nbsp;&nbsp;&nbsp;&nbsp;# vms nit:&nbsp;&nbsp;When encountering &#39;not ok&#39;, vms often has the &#39;not&#39; on a line</td></tr>
<tr><td class="h">69</td><td></td><td></td><td></td><td></td><td></td><td></td><td class="s">&nbsp;&nbsp;&nbsp;&nbsp;# by itself:</td></tr>
<tr><td class="h">70</td><td></td><td></td><td></td><td></td><td></td><td></td><td class="s">&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;&nbsp;&nbsp;not</td></tr>
<tr><td class="h">71</td><td></td><td></td><td></td><td></td><td></td><td></td><td class="s">&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;&nbsp;&nbsp;ok 1 - &#39;I hate VMS&#39;</td></tr>
<tr><td class="h">72</td><td><div class="c3">1689</div></td><td><div class="c3" title="T/F"><a href="blib-lib-TAP-Parser-Iterator-pm--branch.html#L72">100</a></div></td><td><div class="c3"><a href="blib-lib-TAP-Parser-Iterator-pm--condition.html#L72">100</a></div></td><td></td><td></td><td><div>4909</div></td><td class="s">&nbsp;&nbsp;&nbsp;&nbsp;if ( defined($line) and $line =~ /^\s*not\s*$/ ) {</td></tr>
<tr><td class="h">73</td><td><div class="c3">4</div></td><td></td><td><div class="c3"><a href="blib-lib-TAP-Parser-Iterator-pm--condition.html#L73">100</a></div></td><td></td><td></td><td><div>8</div></td><td class="s">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$line .= ( $self-&gt;next_raw || &#39;&#39; );</td></tr>
<tr><td class="h">74</td><td></td><td></td><td></td><td></td><td></td><td></td><td class="s">&nbsp;&nbsp;&nbsp;&nbsp;}</td></tr>
<tr><td class="h">75</td><td colspan="7"></td></tr><tr><td class="h">76</td><td><div class="c3">1689</div></td><td></td><td></td><td></td><td></td><td><div>1982</div></td><td class="s">&nbsp;&nbsp;&nbsp;&nbsp;return $line;</td></tr>
<tr><td class="h">77</td><td></td><td></td><td></td><td></td><td></td><td></td><td class="s">}</td></tr>
<tr><td class="h">78</td><td colspan="7"></td></tr><tr><td class="h">79</td><td></td><td></td><td></td><td></td><td></td><td></td><td class="s">sub next_raw {</td></tr>
<tr><td class="h">80</td><td><div class="c0">0</div></td><td></td><td></td><td><div class="c0"><a href="blib-lib-TAP-Parser-Iterator-pm--subroutine.html#L80">0</a></div></td><td><div class="c3">1</div></td><td><div>0</div></td><td class="s">&nbsp;&nbsp;&nbsp;&nbsp;require Carp;</td></tr>
<tr><td class="h">81</td><td><div class="c0">0</div></td><td></td><td></td><td></td><td></td><td><div>0</div></td><td class="s">&nbsp;&nbsp;&nbsp;&nbsp;my $msg = Carp::longmess(&#39;abstract method called directly!&#39;);</td></tr>
<tr><td class="h">82</td><td><div class="c0">0</div></td><td></td><td></td><td></td><td></td><td><div>0</div></td><td class="s">&nbsp;&nbsp;&nbsp;&nbsp;$_[0]-&gt;_croak($msg);</td></tr>
<tr><td class="h">83</td><td></td><td></td><td></td><td></td><td></td><td></td><td class="s">}</td></tr>
<tr><td class="h">84</td><td colspan="7"></td></tr><tr><td class="h">85 - 92</td><td colspan="6"></td><td class="s"><pre>=head3 C&lt;handle_unicode&gt;

If necessary switch the input stream to handle unicode. This only has
any effect for I/O handle based streams.

The default implementation does nothing.

=cut</pre></td></tr>
<tr><td class="h">93</td><td colspan="7"></td></tr><tr><td class="h">94</td><td></td><td></td><td></td><td><div class="c3"><a href="blib-lib-TAP-Parser-Iterator-pm--subroutine.html#L94">10</a></div></td><td><div class="c3">1</div></td><td></td><td class="s">sub handle_unicode { }</td></tr>
<tr><td class="h">95</td><td colspan="7"></td></tr><tr><td class="h">96 - 104</td><td colspan="6"></td><td class="s"><pre>=head3 C&lt;get_select_handles&gt;

Return a list of filehandles that may be used upstream in a select()
call to signal that this Iterator is ready. Iterators that are not
handle-based should return an empty list.

The default implementation does nothing.

=cut</pre></td></tr>
<tr><td class="h">105</td><td colspan="7"></td></tr><tr><td class="h">106</td><td></td><td></td><td></td><td></td><td></td><td></td><td class="s">sub get_select_handles {</td></tr>
<tr><td class="h">107</td><td><div class="c3">10</div></td><td></td><td></td><td><div class="c3"><a href="blib-lib-TAP-Parser-Iterator-pm--subroutine.html#L107">10</a></div></td><td><div class="c3">1</div></td><td><div>11</div></td><td class="s">&nbsp;&nbsp;&nbsp;&nbsp;return;</td></tr>
<tr><td class="h">108</td><td></td><td></td><td></td><td></td><td></td><td></td><td class="s">}</td></tr>
<tr><td class="h">109</td><td colspan="7"></td></tr><tr><td class="h">110 - 126</td><td colspan="6"></td><td class="s"><pre>=head3 C&lt;wait&gt;

B&lt;Note:&gt; this method is abstract and should be overridden.

 my $wait_status = $iter-&gt;wait;

Return the C&lt;wait&gt; status for this iterator.

=head3 C&lt;exit&gt;

B&lt;Note:&gt; this method is abstract and should be overridden.

 my $wait_status = $iter-&gt;exit;

Return the C&lt;exit&gt; status for this iterator.

=cut</pre></td></tr>
<tr><td class="h">127</td><td colspan="7"></td></tr><tr><td class="h">128</td><td></td><td></td><td></td><td></td><td></td><td></td><td class="s">sub wait {</td></tr>
<tr><td class="h">129</td><td><div class="c0">0</div></td><td></td><td></td><td><div class="c0"><a href="blib-lib-TAP-Parser-Iterator-pm--subroutine.html#L129">0</a></div></td><td><div class="c3">1</div></td><td></td><td class="s">&nbsp;&nbsp;&nbsp;&nbsp;require Carp;</td></tr>
<tr><td class="h">130</td><td><div class="c0">0</div></td><td></td><td></td><td></td><td></td><td></td><td class="s">&nbsp;&nbsp;&nbsp;&nbsp;my $msg = Carp::longmess(&#39;abstract method called directly!&#39;);</td></tr>
<tr><td class="h">131</td><td><div class="c0">0</div></td><td></td><td></td><td></td><td></td><td></td><td class="s">&nbsp;&nbsp;&nbsp;&nbsp;$_[0]-&gt;_croak($msg);</td></tr>
<tr><td class="h">132</td><td></td><td></td><td></td><td></td><td></td><td></td><td class="s">}</td></tr>
<tr><td class="h">133</td><td colspan="7"></td></tr><tr><td class="h">134</td><td></td><td></td><td></td><td></td><td></td><td></td><td class="s">sub exit {</td></tr>
<tr><td class="h">135</td><td><div class="c0">0</div></td><td></td><td></td><td><div class="c0"><a href="blib-lib-TAP-Parser-Iterator-pm--subroutine.html#L135">0</a></div></td><td><div class="c3">1</div></td><td></td><td class="s">&nbsp;&nbsp;&nbsp;&nbsp;require Carp;</td></tr>
<tr><td class="h">136</td><td><div class="c0">0</div></td><td></td><td></td><td></td><td></td><td></td><td class="s">&nbsp;&nbsp;&nbsp;&nbsp;my $msg = Carp::longmess(&#39;abstract method called directly!&#39;);</td></tr>
<tr><td class="h">137</td><td><div class="c0">0</div></td><td></td><td></td><td></td><td></td><td></td><td class="s">&nbsp;&nbsp;&nbsp;&nbsp;$_[0]-&gt;_croak($msg);</td></tr>
<tr><td class="h">138</td><td></td><td></td><td></td><td></td><td></td><td></td><td class="s">}</td></tr>
<tr><td class="h">139</td><td colspan="7"></td></tr><tr><td class="h">140</td><td></td><td></td><td></td><td></td><td></td><td></td><td class="s">1;</td></tr>
<tr><td class="h">141</td><td colspan="7"></td></tr><tr><td class="h">142 - 161</td><td colspan="6"></td><td class="s"><pre>=head1 SUBCLASSING

Please see L&lt;TAP::Parser/SUBCLASSING&gt; for a subclassing overview.

You must override the abstract methods as noted above.

=head2 Example

L&lt;TAP::Parser::Iterator::Array&gt; is probably the easiest example to follow.
There&#39;s not much point repeating it here.

=head1 SEE ALSO

L&lt;TAP::Object&gt;,
L&lt;TAP::Parser&gt;,
L&lt;TAP::Parser::Iterator::Array&gt;,
L&lt;TAP::Parser::Iterator::Stream&gt;,
L&lt;TAP::Parser::Iterator::Process&gt;,

=cut</pre></td></tr>
<tr><td class="h">162</td><td colspan="7"></td></tr></table>
</body>
</html>
